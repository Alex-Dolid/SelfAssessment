## Asynchronous programming

- Theory
  - Event loop ğŸ™‹
  - `try..catch` ğŸ™‹
  - Non-blocking ğŸ™‹
  - Async I/O ğŸ–ï¸
  - Thread pool ğŸ“
  - Pattern Reactor ğŸ‘‚
  - CAS operations ğŸ‘‚
  - epoll ğŸ‘‚
  - kqueue ğŸ‘‚
  - Completion ports ğŸ‘‚
  - Event ports ğŸ‘‚
  - libuv ğŸ“
  - Race conditions ğŸ“
  - Dead locks ğŸ‘‚
  - Live locks ğŸ‘‚
  - Concurrent programming ğŸ“
  - Parallel programming ğŸ“
  - Actor Model ğŸ‘‚
  - Thread ğŸ“
  - Process ğŸ“
- Async contracts
  - Callbacks ğŸ™‹
  - Callback-last-error-first ğŸ™‹
  - Thenable ğŸ–ï¸
  - Promise ğŸ™‹
  - Async/await ğŸ™‹
  - Future ğŸ‘‚
  - Deferred ğŸ‘‚
  - Sync generator ğŸ–ï¸
  - Async Generator ğŸ–ï¸
  - Async Iterator ğŸ–ï¸
  - Event ğŸ™‹
  - Coroutine ğŸ‘‚
  - Goroutine ğŸ‘‚
  - Signal ğŸ‘‚
  - Stream ğŸ–ï¸
  - Chain of responsibility ğŸ–ï¸
  - Middleware ğŸ–ï¸
  - Locks ğŸ“
- Async adapters and utils
  - callbackify ğŸ“
  - promisify ğŸ–ï¸
  - asyncify ğŸ‘‚
  - Callbacks compose ğŸ–ï¸
  - Async compose ğŸ–ï¸
- Async abstractions interfaces
  - EventEmitter ğŸ–ï¸
  - Observable/Observer ğŸ–ï¸
  - Readable ğŸ–ï¸
  - Writable ğŸ–ï¸
  - Transform ğŸ–ï¸
  - Async Pool ğŸ“
  - Async Queue ğŸ“
  - Async Collector ğŸ‘‚
  - Semaphore ğŸ‘‚
  - Mutex ğŸ‘‚
  - Spin Lock ğŸ‘‚
- JavaScript & Node.js specific
  - Timers ğŸ–ï¸
  - `setImmediate` ğŸ–ï¸
  - `nextTick` ğŸ“
  - AbortController ğŸ“
  - AbortSignal ğŸ“
  - Promise unhandled rejection ğŸ–ï¸
  - Promise double resolve ğŸ“
  - Atomics ğŸ‘‚
  - High resolution clock ğŸ‘‚
  - Callback hell ğŸ™‹
  - Promise hell ğŸ™‹
  - ref() and unref() ğŸ‘‚
  - Error handling in async code ğŸ–ï¸
  - Better stack traces with return await ğŸ–ï¸
  - JSON streaming serialization ğŸ“
  - AsyncLocalStorage ğŸ‘‚
  - AsyncResource ğŸ‘‚
- Techniques
  - Async.js library ğŸ‘‚
  - RxJS library ğŸ–ï¸
  - Promise.all ğŸ–ï¸
  - Promise.allSettled ğŸ–ï¸
  - Promise.race ğŸ–ï¸
  - Promise.any ğŸ–ï¸
  - Web Locks API ğŸ‘‚
  - IPC ğŸ‘‚
  - Channel API ğŸ‘‚
  - Revealing constructor ğŸ‘‚
