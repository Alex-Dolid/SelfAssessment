## Multi-paradigm programming

- Theory
  - Procedural programming ğŸ–ï¸
  - Imperative programming ğŸ–ï¸
  - Structured programming ğŸ–ï¸
  - Non-structured programming ğŸ–ï¸
  - Functional programming ğŸ–ï¸
  - Prototype-based programming ğŸ™‹
  - Object-oriented programming ğŸ™‹
  - Object-based programming ğŸ–ï¸
  - Generic programming ğŸ–ï¸
  - Concurrent computing ğŸ“
  - Asyncronous programming ğŸ™‹
  - Parallel programming ğŸ“
  - Reactive programming ğŸ“
  - Functional-reactive (FRP) ğŸ“
  - Automata-based programming ğŸ‘‚
  - Domain-specific languages ğŸ‘‚
  - Multi-paradigm programming ğŸ–ï¸
  - Metaprogramming ğŸ–ï¸
  - Actor model ğŸ“
  - Lambda calculus ğŸ™‹
  - Black box ğŸ“
  - Information hiding ğŸ“
  - Aspect-oriented programming ğŸ‘‚
- OOP basics
  - Constructor ğŸ™‹
  - Operator `new` ğŸ™‹
  - Static method ğŸ™‹
  - Method ğŸ™‹
  - Async method ğŸ™‹
  - Getters, Setters ğŸ™‹
  - Public fields ğŸ™‹
  - Private fields ğŸ™‹
  - Field declarations ğŸ™‹
  - Inheritance ğŸ™‹
  - Parent class ğŸ™‹
  - Polymorphism ğŸ™‹
  - Abstract class ğŸ™‹
  - Interface ğŸ™‹
  - Encapsulation ğŸ™‹
  - Hidden class ğŸ‘‚
  - Object form ğŸ–ï¸
  - Instance ğŸ™‹
  - Introspection ğŸ–ï¸
  - Reflection ğŸ“
  - The diamond problem ğŸ‘‚
- Patterns
  - Singleton ğŸ™‹
  - Factory Method ğŸ™‹
  - Abstract Factory ğŸ“
  - Adapter ğŸ™‹
  - Observer ğŸ–ï¸
  - Strategy ğŸ™‹
  - Facade ğŸ–ï¸
  - Proxy ğŸ–ï¸
  - Chain of Responsibility ğŸ–ï¸
  - Command ğŸ“
  - Iterator ğŸ–ï¸
  - State ğŸ–ï¸
  - Bridge ğŸ–ï¸
  - Builder ğŸ–ï¸
  - Prototype ğŸ™‹
  - Composite ğŸ–ï¸
  - Decorator ğŸ–ï¸
  - Flyweight ğŸ‘‚
  - Mediator ğŸ“
  - Memento ğŸ‘‚
  - Template Method ğŸ‘‚
  - Visitor ğŸ‘‚
  - Reactor ğŸ‘‚
  - Active object ğŸ‘‚
  - Delegation ğŸ‘‚
